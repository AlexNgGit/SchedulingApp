#include "Project.h"
#include <sys/stat.h>
#include "OpenXLSX.hpp"
// Generated by chatGPT
void splitComma(string& str, vector<string>& vect) {
    stringstream ss(str);
    std::string s;
    while (!ss.eof()) {
        std::string s;
        if (std::getline(ss, s, ',')) {
            // Remove leading and trailing whitespace from the extracted string
            size_t start = s.find_first_not_of(' ');
            size_t end = s.find_last_not_of(' ');
            if (start != std::string::npos && end != std::string::npos) {
                vect.push_back(s.substr(start, end - start + 1));
            }
        }
    }
}

string processName(const XLCell& cell) {
    string value = cell.value().get<string>();
    if (value.empty()) {
        throw logic_error("Not valid taskName");
    }
    return value;
}


 double processDouble(const XLCell& cell) {
    if (cell.value().typeAsString() == "double") {
        return cell.value().get<double>();
    } else if (cell.value().typeAsString() == "integer") {
        return (double) cell.value().get<int>();
    } else {
        throw logic_error("Error with numerical input");
    }
}

Project::Project() {
    this->name = "";
    this->ECT = 0;
}

Project::Project(std::string name) {
    this->name = name;
    this->ECT = 0;
}

shared_ptr<Task> Project::findTask(std::string taskName) {
    for (auto element: input) {
        if (element->getName() == taskName) {
            return element;
        }
    }
    return nullptr;
}
//TODO: this is very bad bad way (2 loops !!!) to add dependencies. Need to come up with a new way

int Project::addDependecies(int rowCount, const XLWorksheet& currSheet) {
    int subElementIndex = 2;
    for (auto element: input) {
        vector<string> dependenciesStr;
        //TODO: add guards for cases tasks' name being number type;
        auto currDepenecies = currSheet.cell("D" + to_string(subElementIndex)).value().get<string>();
        splitComma(currDepenecies, dependenciesStr);
        for (const auto& subElement: dependenciesStr) {
                auto elementTask =  findTask(subElement);
                if (elementTask != nullptr) {
                   element->addParentNode(elementTask);
                }
        }
        subElementIndex++;
    }
    return 1;
}


int Project::loadExcelFiles(string path) {
    XLDocument doc = XLDocument(path);
    auto wb = doc.workbook();
    int16_t index = 1;
    auto name = wb.sheet(index).name();
    auto currSheet = wb.worksheet(name);

    while (index <= wb.sheetCount() ) {
        int subIndex = 2;
        while (subIndex <= currSheet.rowCount()) {
            string taskName = processName(currSheet.cell("A"+ to_string(subIndex)));
            auto duration = processDouble(currSheet.cell("B" + to_string(subIndex)));
            auto cost = processDouble(currSheet.cell("C" + to_string(subIndex)));
            shared_ptr<Task> newTask (new Task(duration, cost, taskName, vector< shared_ptr<Task> >()));
            input.push_back(newTask);
            subIndex++;
        }
        index++;
    }
    addDependecies(currSheet.rowCount() , currSheet);
    doc.close();
    return 1;
}


int Project::loadProjectHelper(string pathname) {
    struct stat fileInfo;
    if(stat(pathname.c_str(), &fileInfo) == 0) {
        if(S_ISREG(fileInfo.st_mode)) {
            future<int> ret = async([&]() { return this->loadExcelFiles(pathname); });
            if (!ret.get()) {
                throw logic_error("FAIL TO LOAD FILE");
            }
            return 1;
        }
    } else {
        throw logic_error("NOT VALID FILE");
    }
    return 0;
}

future<int> Project::addTasks(string pathName) {
    return async(std::launch::async, [&]{
        return this->loadProjectHelper(pathName);
    });
}

const vector<shared_ptr<Task>> &Project::getInput() const {
    return input;
}

